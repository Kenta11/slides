<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Kenta Arai">
  <title>6. Enumとパターンマッチング</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/reset.css">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/theme/sky.css" id="theme">
  <link rel="stylesheet" href="custom.css"/>
  <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/notosansjapanese.css" />
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">6. Enumとパターンマッチング</h1>
  <p class="author">Kenta Arai</p>
  <p class="date">2021/8/20</p>
</section>

<section id="copyright" class="title-slide slide level1">
<h1>Copyright</h1>
<ul>
<li>The Rust trademark is owned and protected by The Rust Foundation</li>
<li><a href="https://github.com/rust-lang/book">The Rust Programming Language</a> is licensed under <a href="https://github.com/rust-lang/book/blob/main/COPYRIGHT">Apatch 2.0 and MIT terms</a></li>
<li>This slide is a derivative work of TRPL, and is licensed under Apatch 2.0 and MIT terms</li>
</ul>
</section>

<section id="アウトライン" class="title-slide slide level1">
<h1>アウトライン</h1>
<ul>
<li>この章のトピック：<strong>列挙型(Enum)</strong>
<ul>
<li>Rustでは呼吸をするように列挙型を使います</li>
<li>TRPLでも頻出する，大事な機能</li>
</ul></li>
<li>Enumを使う上で便利な機能についても取り上げます
<ul>
<li>Option型: そもそも値があるか？を表現する列挙型</li>
<li>match式: switch文ライクで，網羅的なフロー制御機能</li>
<li>if let: 列挙型を使う上で便利な慣用句</li>
</ul></li>
</ul>
</section>

<section id="enumを定義する" class="title-slide slide level1">
<h1>6.1 Enumを定義する</h1>
<ul>
<li>Rustでは表現したい内容によって，構造体よりも列挙型が好ましいケースがある</li>
<li>例題：IPアドレスの規格を表現してみましょう
<ul>
<li>IPアドレスの規格：IPv4とIPv6</li>
</ul></li>
<li>列挙型の各列挙子はインスタンスとして生成できます</li>
</ul>
<pre><code>enum IpAddrKind {
    V4,
    V6,
}

let four = IpAddrKind::V4;
let six = IpAddrKind::V6;</code></pre>
</section>

<section id="enumの値" class="title-slide slide level1">
<h1>Enumの値</h1>
<ul>
<li>列挙子は列挙型の名前で名前空間分けがされている
<ul>
<li><code>列挙型名::列挙子名</code></li>
</ul></li>
<li>列挙型は型なので，変数宣言や関数の引数の型として使える</li>
</ul>
<pre><code>let four = IpAddrKind::V4;
let six: IpAddrKind = IpAddrKind::V6;

fn route(ip_type: IpAddrKind) { /* 省略 */ }</code></pre>
</section>

<section id="enumのメリット" class="title-slide slide level1">
<h1>Enumのメリット</h1>
<ul>
<li>列挙型を使うことで，IPアドレスの種類を分類できました</li>
<li>ではIPアドレスそのもの（データ）はどうやって保持したらいいでしょうか？</li>
<li><strong>列挙型にはデータを紐付けることができます</strong></li>
</ul>
<pre><code>enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));
let loopback = IpAddr::V6(String::from(&quot;::1&quot;));</code></pre>
</section>

<section id="enumに紐付けるデータは異なる型でもok" class="title-slide slide level1">
<h1>Enumに紐付けるデータは異なる型でもOK</h1>
<ul>
<li>IPv4とIPv6は表現構造が違います
<ul>
<li>IPv4: 0から255までのいずれかの値を持つ，4つの数値</li>
<li>IPv6: 0から65535までのいずれかの値を持つ，8つの数値</li>
</ul></li>
<li>もしIPv4を数値で表現したければ…？</li>
</ul>
<pre><code>enum IpAddr {
    V4(u8, u8, u8, u8), // IPv4は個別の値を保持したいな
    V6(String),         // IPv6は長いから文字列でいいや
}

let home = IpAddr::V4(127, 0, 0, 1);
let loopback = IpAddr::V6(String::from(&quot;::1&quot;));</code></pre>
</section>

<section id="参考標準ライブラリのipアドレスはこんな実装" class="title-slide slide level1">
<h1>【参考】標準ライブラリのIPアドレスはこんな実装</h1>
<pre><code>struct Ipv4Addr { /* 省略 */ }

struct Ipv6Addr { /* 省略 */ }

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}</code></pre>
</section>

<section id="列挙型-v.s.-構造体" class="title-slide slide level1">
<h1>列挙型 v.s. 構造体</h1>
<ul>
<li>より複雑なデータを扱うとどうなるだろう？</li>
</ul>
<pre><code>enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}</code></pre>
<pre><code>struct QuitMessage; // ユニット構造体
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // タプル構造体
struct ChangeColorMessage(i32, i32, i32); // タプル構造体</code></pre>
</section>

<section id="enumに関数を関連付ける" class="title-slide slide level1">
<h1>Enumに関数を関連付ける</h1>
<ul>
<li>構造体と同様にメソッドを定義できる</li>
</ul>
<pre><code>impl Message {
    fn call(&amp;self) {
        // メソッド本体はここに定義される
    }
}

let m = Message::Write(String::from(&quot;hello&quot;));
m.call();</code></pre>
</section>

<section id="null値の問題点" class="title-slide slide level1">
<h1>Null値の問題点</h1>
<ul>
<li>CやJavaでは，データが無いことをNullで表現する</li>
<li>Nullを適切に扱うのはプログラマの責任</li>
<li>もしNullの値を有効な値として使ったらどうなるだろう？
<ul>
<li>変数だったら…予期せぬ値を読み書き</li>
<li>関数だったら…でたらめな処理を始めてしまう</li>
<li>e.x. Unix系OSにおけるsegmentation fault, JavaにおけるNullPointerException</li>
</ul></li>
</ul>
</section>

<section id="option型" class="title-slide slide level1">
<h1>Option<T>型</h1>
<ul>
<li>値の有無を表現する型</li>
<li>とても便利なので，初期化処理(prelude)でも使われている
<ul>
<li>明示的にスコープ内へ導入する必要が無い</li>
</ul></li>
</ul>
<pre><code>enum Option&lt;T&gt; {
    Some(T),
    None,
}</code></pre>
<pre><code>let some_number = Some(5);
let some_string = Some(&quot;a string&quot;);

let absent_number: Option&lt;i32&gt; = None;</code></pre>
</section>

<section id="nullと比べてなぜ便利" class="title-slide slide level1">
<h1>Nullと比べてなぜ便利？</h1>
<ul>
<li><strong>値に直接アクセスできないため</strong></li>
<li>そもそもコンパイルエラーに</li>
</ul>
<pre><code>let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(3);

let sum = x + y;</code></pre>
<pre><code>   Compiling playground v0.0.1 (/playground)
error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:6:17
  |
6 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`
  |
  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `playground`

To learn more, run the command again with --verbose.</code></pre>
</section>

<section id="補足値を取り出すには" class="title-slide slide level1">
<h1>【補足】値を取り出すには？</h1>
<ul>
<li>unwrap()を使う
<ul>
<li>Someなら関連付けられた値を得られる</li>
<li>Noneだとそこでpanicに</li>
</ul></li>
<li>安全に値を取り出すには→6.2以降で</li>
</ul>
<pre><code>let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(3);

let sum = x + y.unwrap();</code></pre>
</section>

<section id="matchフロー制御演算子" class="title-slide slide level1">
<h1>6.2 matchフロー制御演算子</h1>
<ul>
<li>マッチしたパターンに応じてコードを実行するフロー制御演算子</li>
<li><code>match</code>は式であるため，値を返す</li>
</ul>
<pre><code>enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u32 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}</code></pre>
</section>

<section id="matchは包括的" class="title-slide slide level1">
<h1>matchは包括的</h1>
<ul>
<li>matchで網羅的にパターンが列挙されていないと，コンパイルエラーに</li>
</ul>
<pre><code>fn value_in_cents(coin: Coin) -&gt; u32 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        // Coin::Quarter =&gt; 25,
    }
}</code></pre>
<pre><code>    Compiling playground v0.0.1 (/playground)
error[E0004]: non-exhaustive patterns: `Quarter` not covered
 --&gt; src/main.rs:9:11
  |
1 | / enum Coin {
2 | |     Penny,
3 | |     Nickel,
4 | |     Dime,
5 | |     Quarter,
  | |     ------- not covered
6 | | }
  | |_- `Coin` defined here
...
9 |       match coin {
  |             ^^^^ pattern `Quarter` not covered
  |
  = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
  = note: the matched value is of type `Coin`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0004`.
error: could not compile `playground`

To learn more, run the command again with --verbose.</code></pre>
</section>

<section id="というプレースホルダー" class="title-slide slide level1">
<h1>_というプレースホルダー</h1>
<ul>
<li>全てのパターンを列挙したくない場合，_が便利です</li>
<li>_はその他全てのパターンに対してマッチします</li>
<li>()はユニット値（何も無い）です</li>
</ul>
<pre><code>let some_u8_value = 0u8;
match some_u8_value {
    1 =&gt; println!(&quot;one&quot;),
    3 =&gt; println!(&quot;three&quot;),
    5 =&gt; println!(&quot;five&quot;),
    7 =&gt; println!(&quot;seven&quot;),
    _ =&gt; (),
}</code></pre>
</section>

<section id="値に束縛されるパターン" class="title-slide slide level1">
<h1>値に束縛されるパターン</h1>
<ul>
<li><code>match</code>はマッチした値を束縛できる</li>
<li>コインにデザインされた州名を表示してみましょう
<ul>
<li>一時期のQuaterコインは州ごとにデザインされていた</li>
</ul></li>
<li>ところで原本の題目は<code>Patterns that Bind to Values</code>
<ul>
<li>実際は，値を束縛するパターン？</li>
</ul></li>
</ul>
<pre><code>#[derive(Debug)] // すぐに州を点検できるように
enum UsState {
    Alabama,
    Alaska,
    // ... などなど
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -&gt; u32 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!(&quot;State quarter from {:?}!&quot;, state);
            25
        },
    }
}</code></pre>
</section>

<section id="optionとのマッチ" class="title-slide slide level1">
<h1>Option<T>とのマッチ</h1>
<ul>
<li>Option<T>に関連付けられたデータを取り出すには？</li>
<li>Optionももちろん列挙型なので，<code>match</code>で扱えます</li>
</ul>
<pre><code>fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}
    
let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);</code></pre>
</section>

<section id="if-letで簡潔なフロー制御" class="title-slide slide level1">
<h1>6.3 if letで簡潔なフロー制御</h1>
<ul>
<li>1つの値にしか興味が無い場合，<code>match</code>は少し長い</li>
<li><code>if let</code>はより短い表現で値をマッチさせることができます</li>
</ul>
<pre><code>// matchだとちょっと長い
let some_u8_value = Some(0u8);
match some_u8_value {
    Some(3) =&gt; println!(&quot;three&quot;),
    _ =&gt; (),
}

// if letだと簡潔
if let Some(3) = some_u8_value {
    println!(&quot;three&quot;);
}</code></pre>
</section>

<section id="まとめ" class="title-slide slide level1">
<h1>まとめ</h1>
<ul>
<li>Rustで頻出するEnumについて述べた</li>
<li>Enumに関する便利な機能について取り上げた
<ul>
<li>Option型: 値の有無を表現する列挙型</li>
<li>match式: 網羅的なフロー制御機能</li>
<li>if let: 列挙型を使う上で便利な慣用句</li>
</ul></li>
</ul>
</section>
    </div>
  </div>

  <script src="https://unpkg.com/reveal.js@^4//dist/reveal.js"></script>

  <!-- reveal.js plugins -->
  <script src="https://unpkg.com/reveal.js@^4//plugin/notes/notes.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/search/search.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/zoom/zoom.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
      
        // Display the page number of the current slide
        slideNumber: true,
        // Push each slide change to the browser history
        history: true,

        // reveal.js plugins
        plugins: [
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    </body>
</html>
